### Learning Objectives

* Demonstrate how variables are stored in memory using Ruby.
* Use `!` to modify values in memory.
* Demonstrate how symbols are immutable data types in Ruby.

> AM: Add more details learning objectives.

### Framing

In Javascript, we don't have to worry about our actions having unintended consequences in memory. Take the following example...

```js
var aString = "hello world";

var pointToThatString = aString;
// Here we might expect that `pointToThatString` will point to the same location in memory that `aString` is pointing too.

aString;
// => "hello world"

pointToThatString;
// => "hello world"
```

So both variables print the same value to the console.
* What happens if we modify the value that is stored in `aString`. Will that then change what is stored in `pointToThatString`?

```js
aString = aString.toUpperCase();
aString;
// => "HELLO WORLD"

pointToThatString;
// => ???
```
> AM: Is this the best example to show that we don't need to worry about memory allocation the same way we do in Ruby?

In Ruby, there are situations like these that don't play out the same way. Today we'll learn about how Ruby memory allocation may have unintended consequences. We'll also learn about immutable data types such as Symbols that are not subject to changes.

### Variables and Mutability (15min)

Let's talk about variables and memory allocation in Ruby.

Haha!

![XKCD pointers comic](https://camo.githubusercontent.com/e015a8e243f53ffecd9b18fc5c8d770dde1948cc/687474703a2f2f626c6f672e70726f7465637465647374617469632e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030372f30352f706f696e746572732e706e67)

Why is that so funny? Because variables are pointers to values in memory.

![Variables in memory diagram](https://camo.githubusercontent.com/62b04af497f124fc9b11ec3802d73497f5c9e305/687474703a2f2f64326177357865326a6c647175652e636c6f756466726f6e742e6e65742f626f6f6b732f727562792f696d616765732f7661726961626c65735f706f696e74657273312e6a7067)

<a href="https://imgflip.com/gif/t9736"><img src="https://i.imgflip.com/t9736.gif" title="made at imgflip.com"/></a>

#### .object_id

We can use the `.object_id` method to demonstrate that two variables are pointing to the same object.
* Returns an integer identifier for the object that is automatically generated by Ruby

```rb
a = 10
# => 10

b = a
# => 10

a.object_id
# => 21

b.object_id
# => 21
```

#### Bang! (The `!`)

All of the Ruby data types we have discussed so far -- with the exception of numbers -- are data types in Ruby are mutable.
* We can not only change what values in memory variables are pointing to, but we can change those values in memory as well.

Methods with an `!` attached to the end of them usually means that they will modify the object they are calling on.
* Things can get tricky when you have multiple variables pointing at the same value. For example...

```rb
a = "cheeseburger"
# => "cheeseburger"

b = a
# => "cheeseburger"

b.upcase!
# => "CHEESEBURGER"

a
# => "CHEESEBURGER"
```

#### Garbage Collection

What happens to a value in memory when it is no longer being pointed at by a variable?

```rb
a = 10
b = a

a # => 10
b # => 10

a = 20
b # => 10

b = 30
b # => 30
```
> AM: Make sure to whiteboard this out. Code snippet not enough.

What happened to the memory location that stored `10` at the start of the above code snippet? **Garbage Collection.**
* Because nothing is pointing to that memory location, Ruby clears it up for later use.

#### Reassignment...  
<a href="https://imgflip.com/gif/t984f"><img src="https://i.imgflip.com/t984f.gif" title="made at imgflip.com"/></a>

#### ...vs Replacement
<a href="https://imgflip.com/gif/t98b3"><img src="https://i.imgflip.com/t98b3.gif" title="made at imgflip.com"/></a>

#### Exercise: Variable Assignment (15min)

[Exercise: Variable Assignment](https://gist.github.com/amaseda/35a62128d8795e045d49)
* Work in pairs and answer the questions in the link above.
* **NO CODING ALLOWED!** Stretch those brain muscles and talk these out with your partner.
* Writing these out on your table/whiteboard with markers is strongly encouraged.

### Symbols and (Im)mutability (5min)

Symbols are immutable values. That means they contain the same value through the entirety of a program and cannot be changed.
* Kind of like a string that never changes.
* Syntax: `variable_name = :symbol_name`
* No Javascript equivalent (that is, [until ES6 came along](https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/)).

```rb
favorite_animal = :dog
# => :dog

puts favorite_animal
# dog
# => nil

other_favorite_animal = :killer_whale
# => :killer_whale

another_favorite_animal = :"flying squirrel"
# => :"flying squirrel"
```

You can convert symbols to -- but not replace them with -- other data types.

```rb
favorite_animal = :dog
# => :dog

favorite_animal.to_s
# => "dog"

favorite_animal = :dog
# => :dog
```

#### When/Why Would You Use Symbols?

##### Enhance performance. Use less memory.  
Not only can symbols not be changed, but each symbol occupies one place in memory no matter how many times it is used.  

```rb
george_washington = :president
# => :president

barack_obama = :president
# => :president

george_washington.object_id
# => 3202868

barack_obama.object_id
# => 3202868
```

##### Representing constant concepts.

Say we have a variable `light_switch`. We know that it will only have two values: `on` or `off`.
* As such, we know it will never be anything other than `on` or `off`. We also know that we will never need to modify the values `on` or `off`.
* We could use strings to indicate the status of `light_switch`. But in doing that, we are creating a new value in memory every time it changes.

```rb
light_switch = "on"
light_switch.object_id
# => 70217024652700

light_switch = "off"
light_switch.object_id
# => 70217024477120

light_switch = "on"
light_switch.object_id
# => 70217028084580
```
> Note that when `light_switch` is set to `on` for a second time, `"on"` occupies a different place in memory than the first time.

Now this example may not be the best since garbage collection ends up freeing the spaces in memory that are no longer being used.
* But imagine if we were dealing with a light switch for every room in a mansion. That would be a lot of memory locations being used for only two values: `on` and `off`.
* Symbols would allow us to represent `on` and `off`, regardless of how many light switches there are, using only two memory locations.

```rb
light_switch_hallway = :on
light_switch_kitchen = :on
light_switch_bathroom = :on

light_switch_hallway.object_id
# => 2053788

light_switch_kitchen.object_id
# => 2053788

light_switch_bathroom.object_id
# => 2053788
```
> Note that all three variables reference the same location in memory.

This is important because we are trying to represent the **concepts** of `on` and `off`, not the strings. Symbols are a useful way of doing this.

A more practical example: imagine that you have built a web application and you allow the user to sign in using one of a three services: `Facebook` `Twitter` and `Instagram`.
* You indicate this using a `service` instance variable in a `User` class.
* **Q:** How could symbols be useful here?

##### Symbols are often used as keys in hashes.  

* Imagine you're creating hashes to represent every instructor that works for GA. They would something like this...  

```rb
jesse = {
  name: "Jesse Shawl",
  location: "DC",
  cohort: "WDI8"
}

jeff = {
  name: "Jeff Horn",
  location: "Boston",
  cohort: "WDI5"
}
```

We know the keys for each of these hashes will be the exact same. So rather than instantiate these keys as strings and devote a location in memory to each of them -- which could end up totaling in the hundreds! -- why not just use symbols?  
* If each instructor has the same three keys, we only need three memory locations to store them.

> AM: Is there a worthwhile exercise to include that would test their knowledge of symbols?

### Further Reading

* [Tying Ruby Immutability to Functional Programming](http://valve.github.io/blog/2014/07/04/from-object-to-functional-immutability/)
