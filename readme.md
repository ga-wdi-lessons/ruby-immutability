### Learning Objectives

* Demonstrate how variables are stored in memory using Ruby.
* Use `!` to modify values in memory.
* Demonstrate how symbols are immutable data types in Ruby.

### Framing

In Javascript, we don't have to worry about our actions having unintended consequences in memory. Take the following example...

```js
var aString = "hello world";

var pointToThatString = aString;
// Here we might expect that `pointToThatString` will point to the same location in memory that `aString` is pointing too.

aString;
// => "hello world"

pointToThatString;
// => "hello world"
```

So both variables print the same value to the console.
* What happens if we modify the value that is stored in `aString`. Will that then change what is stored in `pointToThatString`?

```js
aString = aString.toUpperCase();
aString;
// => "HELLO WORLD"

pointToThatString;
// => ???
```
> But this code run in Ruby does the same thing...

In Ruby, there are situations like these that don't play out the same way. Today we'll learn about how Ruby memory allocation may have unintended consequences. We'll also learn about immutable data types such as Symbols that are not subject to changes.

### Variables and Mutability (15min)

Let's talk about variables and memory allocation in Ruby.

Haha!

![XKCD pointers comic](https://camo.githubusercontent.com/e015a8e243f53ffecd9b18fc5c8d770dde1948cc/687474703a2f2f626c6f672e70726f7465637465647374617469632e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030372f30352f706f696e746572732e706e67)

Why is that so funny? Because variables are pointers to values in memory.

![Variables in memory diagram](https://camo.githubusercontent.com/62b04af497f124fc9b11ec3802d73497f5c9e305/687474703a2f2f64326177357865326a6c647175652e636c6f756466726f6e742e6e65742f626f6f6b732f727562792f696d616765732f7661726961626c65735f706f696e74657273312e6a7067)

<a href="https://imgflip.com/gif/t9736"><img src="https://i.imgflip.com/t9736.gif" title="made at imgflip.com"/></a>

#### .object_id

We can use the `.object_id` method to demonstrate that two variables are pointing to the same object.
* Returns an integer identifier for the object that is automatically generated by Ruby

```
[29] pry(main)> a = 10
=> 10
[30] pry(main)> b = a
=> 10
[31] pry(main)> a.object_id
=> 21
[32] pry(main)> b.object_id
=> 21
```

#### Bang! (The `!`)

All of the Ruby data types we have discussed so far -- with the exception of numbers -- are data types in Ruby are mutable.
* We can not only change what values in memory variables are pointing to, but we can change those values in memory as well.

Methods with an `!` attached to the end of them usually means that they will modify the object they are calling on.
* Things can get tricky when you have multiple variables pointing at the same value. For example...

```rb
a = "cheeseburger"
# => "cheeseburger"

b = a
# => "cheeseburger"

b.upcase!
# => "CHEESEBURGER"

a
# => "CHEESEBURGER"
```

#### Reassignment...  
<a href="https://imgflip.com/gif/t984f"><img src="https://i.imgflip.com/t984f.gif" title="made at imgflip.com"/></a>

#### ...vs Replacement
<a href="https://imgflip.com/gif/t98b3"><img src="https://i.imgflip.com/t98b3.gif" title="made at imgflip.com"/></a>

#### Exercise: Variable Assignment (15min)

[Exercise: Variable Assignment](https://gist.github.com/amaseda/35a62128d8795e045d49)
* Work in pairs and answer the questions in the link above.
* **NO CODING ALLOWED!** Stretch those brain muscles and talk these out with your partner.
* Writing these out on your table/whiteboard with markers is strongly encouraged.

### Symbols and (Im)mutability (5min)

Symbols are immutable values. That means they contain the same value through the entirety of a program and cannot be changed.
* Kind of like a string that never changes.
* Syntax: `variable_name = :symbol_name`
* No Javascript equivalent (that is, [until ES6 came along](https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/)).

```rb
favorite_animal = :dog
# => :dog

puts favorite_animal
# dog
# => nil

other_favorite_animal = :killer_whale
# => :killer_whale

another_favorite_animal = :"flying squirrel"
# => :"flying squirrel"
```

You can convert symbols to -- but not replace them with -- other data types.

```rb
favorite_animal = :dog
# => :dog

favorite_animal.to_s
# => "dog"

favorite_animal = :dog
# => :dog
```

#### When/Why Would You Use Symbols?

Enhance performance. Use less memory.  

Make sure values that need to be constant stay constant.  

Often used as keys in hashes.  
* Imagine you're creating hashes to represent every instructor that works for GA. They would something like this...  

```rb
jesse = {
  name: "Jesse Shawl",
  location: "DC",
  cohort: "WDI8"
}

jeff = {
  name: "Jeff Horn",
  location: "Boston",
  cohort: "WDI5"
}
```

We know the keys for each of these hashes will be the exact same. So rather than instantiate these keys as strings and devote a location in memory to each of them -- which could end up totaling in the hundreds! -- why not just use symbols?  
* If each instructor has the same three keys, we only need three memory locations to store them.

### Further Reading

* [Tying Ruby Immutability to Functional Programming](http://valve.github.io/blog/2014/07/04/from-object-to-functional-immutability/)
